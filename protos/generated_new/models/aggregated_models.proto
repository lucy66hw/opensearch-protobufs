/*
    This is auto generated by OpenAPI Generator. The source of OpenAPI is opensearch-api-specification
*/

syntax = "proto3";

package org.opensearch.protobufs;


message ObjectMap {
  map<string, Value> fields = 1;

  message Value {
    oneof value {
      int32 int32 = 1;
      int64 int64 = 2;
      float float = 3;
      double double = 4;
      string string = 5;
      bool bool = 6;
      ObjectMap object_map = 7;
      ListValue list_value = 8;
    }
  }

  // `ListValue` is a wrapper around a repeated field of values.
  // The JSON representation for `ListValue` is JSON array.
  message ListValue {
    // Repeated field of dynamically typed values.
    repeated Value value = 1;
  }
}
message AnalyzeDetail {

  optional AnalyzerDetail analyzer = 1;

  // The list of character filter results.
  repeated CharFilterDetail charfilters = 2;

  // Whether a custom analyzer was used.
  bool custom_analyzer = 3;

  // The list of token filter results.
  repeated TokenDetail tokenfilters = 4;

  optional TokenDetail tokenizer = 5;

}
message AnalyzeToken {

  // The ending character offset of the token.
  int32 end_offset = 1;

  // The position of the token.
  int32 position = 2;

  // The length of the token position.
  optional int32 position_length = 3 [json_name="positionLength"];

  // The starting character offset of the token.
  int32 start_offset = 4;

  // The token string.
  string token = 5;

  // The type of the token.
  string type = 6;

}
message AnalyzerDetail {

  // The name of the analyzer.
  string name = 1;

  // The list of tokens produced by the analyzer.
  repeated ExplainAnalyzeToken tokens = 2;

}
message AsciiFoldingTokenFilter {

  optional string version = 1;

  AsciiFoldingTokenFilterAllOfType type = 2;

  optional StringifiedBoolean preserve_original = 3;

}
enum AsciiFoldingTokenFilterAllOfType {

  ASCII_FOLDING_TOKEN_FILTER_ALL_OF_TYPE_UNSPECIFIED = 0;
  ASCII_FOLDING_TOKEN_FILTER_ALL_OF_TYPE_ASCIIFOLDING = 1;

}
enum BuiltinScriptLanguage {

  BUILTIN_SCRIPT_LANGUAGE_UNSPECIFIED = 0;
  BUILTIN_SCRIPT_LANGUAGE_EXPRESSION = 1;
  BUILTIN_SCRIPT_LANGUAGE_JAVA = 2;
  BUILTIN_SCRIPT_LANGUAGE_MUSTACHE = 3;
  BUILTIN_SCRIPT_LANGUAGE_PAINLESS = 4;

}
message CharFilter {

  oneof char_filter {

    string name = 1;

    CharFilterDefinition definition = 2;

  }
}
message CharFilterBase {

  optional string version = 1;

}
message CharFilterDefinition {

  oneof char_filter_definition {

    HtmlStripCharFilter html_strip_char_filter = 1;

    MappingCharFilter mapping_char_filter = 2;

    PatternReplaceCharFilter pattern_replace_char_filter = 3;

    IcuNormalizationCharFilter icu_normalization_char_filter = 4;

    KuromojiIterationMarkCharFilter kuromoji_iteration_mark_char_filter = 5;

  }
}
message CharFilterDetail {

  // The text after character filtering.
  repeated string filtered_text = 1;

  // The name of the character filter.
  string name = 2;

}
message CharGroupTokenizer {

  optional string version = 1;

  CharGroupTokenizerAllOfType type = 2;

  repeated string tokenize_on_chars = 3;

  optional int32 max_token_length = 4;

}
enum CharGroupTokenizerAllOfType {

  CHAR_GROUP_TOKENIZER_ALL_OF_TYPE_UNSPECIFIED = 0;
  CHAR_GROUP_TOKENIZER_ALL_OF_TYPE_CHAR_GROUP = 1;

}
message CommonGramsTokenFilter {

  optional string version = 1;

  CommonGramsTokenFilterAllOfType type = 2;

  repeated string common_words = 3;

  optional string common_words_path = 4;

  optional bool ignore_case = 5;

  optional bool query_mode = 6;

}
enum CommonGramsTokenFilterAllOfType {

  COMMON_GRAMS_TOKEN_FILTER_ALL_OF_TYPE_UNSPECIFIED = 0;
  COMMON_GRAMS_TOKEN_FILTER_ALL_OF_TYPE_COMMON_GRAMS = 1;

}
message CompoundWordTokenFilterBase {

  optional string version = 1;

  optional string hyphenation_patterns_path = 2;

  optional int32 max_subword_size = 3;

  optional int32 min_subword_size = 4;

  optional int32 min_word_size = 5;

  optional bool only_longest_match = 6;

  repeated string word_list = 7;

  optional string word_list_path = 8;

}
message ConditionTokenFilter {

  optional string version = 1;

  ConditionTokenFilterAllOfType type = 2;

  repeated string filter = 3;

  Script script = 4;

}
enum ConditionTokenFilterAllOfType {

  CONDITION_TOKEN_FILTER_ALL_OF_TYPE_UNSPECIFIED = 0;
  CONDITION_TOKEN_FILTER_ALL_OF_TYPE_CONDITION = 1;

}
enum DelimitedPayloadEncoding {

  DELIMITED_PAYLOAD_ENCODING_UNSPECIFIED = 0;
  DELIMITED_PAYLOAD_ENCODING_FLOAT = 1;
  DELIMITED_PAYLOAD_ENCODING_IDENTITY = 2;
  DELIMITED_PAYLOAD_ENCODING_INT = 3;

}
message DelimitedPayloadTokenFilter {

  optional string version = 1;

  DelimitedPayloadTokenFilterAllOfType type = 2;

  optional string delimiter = 3;

  optional DelimitedPayloadEncoding encoding = 4;

}
enum DelimitedPayloadTokenFilterAllOfType {

  DELIMITED_PAYLOAD_TOKEN_FILTER_ALL_OF_TYPE_UNSPECIFIED = 0;
  DELIMITED_PAYLOAD_TOKEN_FILTER_ALL_OF_TYPE_DELIMITED_PAYLOAD = 1;

}
message DictionaryDecompounderTokenFilter {

  optional string version = 1;

  optional string hyphenation_patterns_path = 2;

  optional int32 max_subword_size = 3;

  optional int32 min_subword_size = 4;

  optional int32 min_word_size = 5;

  optional bool only_longest_match = 6;

  repeated string word_list = 7;

  optional string word_list_path = 8;

  DictionaryDecompounderTokenFilterAllOfType type = 9;

}
enum DictionaryDecompounderTokenFilterAllOfType {

  DICTIONARY_DECOMPOUNDER_TOKEN_FILTER_ALL_OF_TYPE_UNSPECIFIED = 0;
  DICTIONARY_DECOMPOUNDER_TOKEN_FILTER_ALL_OF_TYPE_DICTIONARY_DECOMPOUNDER = 1;

}
enum EdgeNGramSide {

  EDGE_N_GRAM_SIDE_UNSPECIFIED = 0;
  EDGE_N_GRAM_SIDE_BACK = 1;
  EDGE_N_GRAM_SIDE_FRONT = 2;

}
message EdgeNGramTokenFilter {

  optional string version = 1;

  EdgeNGramTokenFilterAllOfType type = 2;

  optional int32 max_gram = 3;

  optional int32 min_gram = 4;

  optional EdgeNGramSide side = 5;

  optional StringifiedBoolean preserve_original = 6;

}
enum EdgeNGramTokenFilterAllOfType {

  EDGE_N_GRAM_TOKEN_FILTER_ALL_OF_TYPE_UNSPECIFIED = 0;
  EDGE_N_GRAM_TOKEN_FILTER_ALL_OF_TYPE_EDGE_NGRAM = 1;

}
message EdgeNGramTokenizer {

  optional string version = 1;

  EdgeNGramTokenizerAllOfType type = 2;

  optional string custom_token_chars = 3;

  int32 max_gram = 4;

  int32 min_gram = 5;

  repeated TokenChar token_chars = 6;

}
enum EdgeNGramTokenizerAllOfType {

  EDGE_N_GRAM_TOKENIZER_ALL_OF_TYPE_UNSPECIFIED = 0;
  EDGE_N_GRAM_TOKENIZER_ALL_OF_TYPE_EDGE_NGRAM = 1;

}
message ElisionTokenFilter {

  optional string version = 1;

  ElisionTokenFilterAllOfType type = 2;

  repeated string articles = 3;

  optional string articles_path = 4;

  optional StringifiedBoolean articles_case = 5;

}
enum ElisionTokenFilterAllOfType {

  ELISION_TOKEN_FILTER_ALL_OF_TYPE_UNSPECIFIED = 0;
  ELISION_TOKEN_FILTER_ALL_OF_TYPE_ELISION = 1;

}
message ExplainAnalyzeToken {

  // The bytes representation of the token.
  string bytes = 1;

  // The ending character offset of the token.
  int32 end_offset = 2;

  // Whether the token is a keyword.
  optional bool keyword = 3;

  // The position of the token.
  int32 position = 4;

  // The length of the token position.
  int32 position_length = 5 [json_name="positionLength"];

  // The starting character offset of the token.
  int32 start_offset = 6;

  // The frequency of the term.
  int32 term_frequency = 7 [json_name="termFrequency"];

  // The token string.
  string token = 8;

  // The type of the token.
  string type = 9;

}
message FingerprintTokenFilter {

  optional string version = 1;

  FingerprintTokenFilterAllOfType type = 2;

  optional int32 max_output_size = 3;

  optional string separator = 4;

}
enum FingerprintTokenFilterAllOfType {

  FINGERPRINT_TOKEN_FILTER_ALL_OF_TYPE_UNSPECIFIED = 0;
  FINGERPRINT_TOKEN_FILTER_ALL_OF_TYPE_FINGERPRINT = 1;

}
message HtmlStripCharFilter {

  optional string version = 1;

  HtmlStripCharFilterAllOfType type = 2;

}
enum HtmlStripCharFilterAllOfType {

  HTML_STRIP_CHAR_FILTER_ALL_OF_TYPE_UNSPECIFIED = 0;
  HTML_STRIP_CHAR_FILTER_ALL_OF_TYPE_HTML_STRIP = 1;

}
message HunspellTokenFilter {

  optional string version = 1;

  HunspellTokenFilterAllOfType type = 2;

  optional bool dedup = 3;

  optional string dictionary = 4;

  string locale = 5;

  optional bool longest_only = 6;

}
enum HunspellTokenFilterAllOfType {

  HUNSPELL_TOKEN_FILTER_ALL_OF_TYPE_UNSPECIFIED = 0;
  HUNSPELL_TOKEN_FILTER_ALL_OF_TYPE_HUNSPELL = 1;

}
message HyphenationDecompounderTokenFilter {

  optional string version = 1;

  optional string hyphenation_patterns_path = 2;

  optional int32 max_subword_size = 3;

  optional int32 min_subword_size = 4;

  optional int32 min_word_size = 5;

  optional bool only_longest_match = 6;

  repeated string word_list = 7;

  optional string word_list_path = 8;

  HyphenationDecompounderTokenFilterAllOfType type = 9;

}
enum HyphenationDecompounderTokenFilterAllOfType {

  HYPHENATION_DECOMPOUNDER_TOKEN_FILTER_ALL_OF_TYPE_UNSPECIFIED = 0;
  HYPHENATION_DECOMPOUNDER_TOKEN_FILTER_ALL_OF_TYPE_HYPHENATION_DECOMPOUNDER = 1;

}
enum IcuCollationAlternate {

  ICU_COLLATION_ALTERNATE_UNSPECIFIED = 0;
  ICU_COLLATION_ALTERNATE_NON_IGNORABLE = 1;
  ICU_COLLATION_ALTERNATE_SHIFTED = 2;

}
enum IcuCollationCaseFirst {

  ICU_COLLATION_CASE_FIRST_UNSPECIFIED = 0;
  ICU_COLLATION_CASE_FIRST_LOWER = 1;
  ICU_COLLATION_CASE_FIRST_UPPER = 2;

}
enum IcuCollationDecomposition {

  ICU_COLLATION_DECOMPOSITION_UNSPECIFIED = 0;
  ICU_COLLATION_DECOMPOSITION_CANONICAL = 1;
  ICU_COLLATION_DECOMPOSITION_NO = 2;

}
enum IcuCollationStrength {

  ICU_COLLATION_STRENGTH_UNSPECIFIED = 0;
  ICU_COLLATION_STRENGTH_IDENTICAL = 1;
  ICU_COLLATION_STRENGTH_PRIMARY = 2;
  ICU_COLLATION_STRENGTH_QUATERNARY = 3;
  ICU_COLLATION_STRENGTH_SECONDARY = 4;
  ICU_COLLATION_STRENGTH_TERTIARY = 5;

}
message IcuCollationTokenFilter {

  optional string version = 1;

  IcuCollationTokenFilterAllOfType type = 2;

  optional IcuCollationAlternate alternate = 3;

  optional IcuCollationCaseFirst case_first = 4 [json_name="caseFirst"];

  optional bool case_level = 5 [json_name="caseLevel"];

  optional string country = 6;

  optional IcuCollationDecomposition decomposition = 7;

  optional bool hiragana_quaternary_mode = 8 [json_name="hiraganaQuaternaryMode"];

  optional string language = 9;

  optional bool numeric = 10;

  optional string rules = 11;

  optional IcuCollationStrength strength = 12;

  optional string variable_top = 13 [json_name="variableTop"];

  optional string variant = 14;

}
enum IcuCollationTokenFilterAllOfType {

  ICU_COLLATION_TOKEN_FILTER_ALL_OF_TYPE_UNSPECIFIED = 0;
  ICU_COLLATION_TOKEN_FILTER_ALL_OF_TYPE_ICU_COLLATION = 1;

}
message IcuFoldingTokenFilter {

  optional string version = 1;

  IcuFoldingTokenFilterAllOfType type = 2;

  string unicode_set_filter = 3;

}
enum IcuFoldingTokenFilterAllOfType {

  ICU_FOLDING_TOKEN_FILTER_ALL_OF_TYPE_UNSPECIFIED = 0;
  ICU_FOLDING_TOKEN_FILTER_ALL_OF_TYPE_ICU_FOLDING = 1;

}
message IcuNormalizationCharFilter {

  optional string version = 1;

  IcuNormalizationCharFilterAllOfType type = 2;

  optional IcuNormalizationMode mode = 3;

  optional IcuNormalizationType name = 4;

}
enum IcuNormalizationCharFilterAllOfType {

  ICU_NORMALIZATION_CHAR_FILTER_ALL_OF_TYPE_UNSPECIFIED = 0;
  ICU_NORMALIZATION_CHAR_FILTER_ALL_OF_TYPE_ICU_NORMALIZER = 1;

}
enum IcuNormalizationMode {

  ICU_NORMALIZATION_MODE_UNSPECIFIED = 0;
  ICU_NORMALIZATION_MODE_COMPOSE = 1;
  ICU_NORMALIZATION_MODE_DECOMPOSE = 2;

}
message IcuNormalizationTokenFilter {

  optional string version = 1;

  IcuNormalizationTokenFilterAllOfType type = 2;

  IcuNormalizationType name = 3;

}
enum IcuNormalizationTokenFilterAllOfType {

  ICU_NORMALIZATION_TOKEN_FILTER_ALL_OF_TYPE_UNSPECIFIED = 0;
  ICU_NORMALIZATION_TOKEN_FILTER_ALL_OF_TYPE_ICU_NORMALIZER = 1;

}
enum IcuNormalizationType {

  ICU_NORMALIZATION_TYPE_UNSPECIFIED = 0;
  ICU_NORMALIZATION_TYPE_NFC = 1;
  ICU_NORMALIZATION_TYPE_NFKC = 2;
  ICU_NORMALIZATION_TYPE_NFKC_CF = 3;

}
message IcuTokenizer {

  optional string version = 1;

  IcuTokenizerAllOfType type = 2;

  string rule_files = 3;

}
enum IcuTokenizerAllOfType {

  ICU_TOKENIZER_ALL_OF_TYPE_UNSPECIFIED = 0;
  ICU_TOKENIZER_ALL_OF_TYPE_ICU_TOKENIZER = 1;

}
enum IcuTransformDirection {

  ICU_TRANSFORM_DIRECTION_UNSPECIFIED = 0;
  ICU_TRANSFORM_DIRECTION_FORWARD = 1;
  ICU_TRANSFORM_DIRECTION_REVERSE = 2;

}
message IcuTransformTokenFilter {

  optional string version = 1;

  IcuTransformTokenFilterAllOfType type = 2;

  optional IcuTransformDirection dir = 3;

  string id = 4;

}
enum IcuTransformTokenFilterAllOfType {

  ICU_TRANSFORM_TOKEN_FILTER_ALL_OF_TYPE_UNSPECIFIED = 0;
  ICU_TRANSFORM_TOKEN_FILTER_ALL_OF_TYPE_ICU_TRANSFORM = 1;

}
message IndicesAnalyzeRequest {

  // The name of the analyzer that should be applied to the provided `text`. This could be a built-in analyzer, or an analyzer that's been configured in the index.
  optional string analyzer = 1;

  // Array of token attributes used to filter the output of the `explain` parameter.
  repeated string attributes = 2;

  // Array of character filters used to preprocess characters before the tokenizer.
  repeated CharFilter char_filter = 3;

  // If `true`, the response includes token attributes and additional details.
  optional bool explain = 4;

  // The path to a field or an array of paths. Some APIs support wildcards in the path, which allows you to select multiple fields.
  optional string field = 5;

  // Array of token filters used to apply after the tokenizer.
  repeated TokenFilter filter = 6;

  // Normalizer to use to convert text into a single token.
  optional string normalizer = 7;

  repeated string text = 8;

  optional Tokenizer tokenizer = 9;

}
message InlineObject {

  optional AnalyzeDetail detail = 1;

  repeated AnalyzeToken tokens = 2;

}
message InlineScript {

  // Specifies any named parameters that are passed into the script as variables.  Use parameters instead of hard-coded values to decrease compilation time. 
  optional ObjectMap params = 1;

  optional ScriptLanguage lang = 2;

  map<string, string> options = 3;

  // The script source.
  string source = 4;

}
message KStemTokenFilter {

  optional string version = 1;

  KStemTokenFilterAllOfType type = 2;

}
enum KStemTokenFilterAllOfType {

  K_STEM_TOKEN_FILTER_ALL_OF_TYPE_UNSPECIFIED = 0;
  K_STEM_TOKEN_FILTER_ALL_OF_TYPE_KSTEM = 1;

}
enum KeepTypesMode {

  KEEP_TYPES_MODE_UNSPECIFIED = 0;
  KEEP_TYPES_MODE_EXCLUDE = 1;
  KEEP_TYPES_MODE_INCLUDE = 2;

}
message KeepTypesTokenFilter {

  optional string version = 1;

  KeepTypesTokenFilterAllOfType type = 2;

  optional KeepTypesMode mode = 3;

  repeated string types = 4;

}
enum KeepTypesTokenFilterAllOfType {

  KEEP_TYPES_TOKEN_FILTER_ALL_OF_TYPE_UNSPECIFIED = 0;
  KEEP_TYPES_TOKEN_FILTER_ALL_OF_TYPE_KEEP_TYPES = 1;

}
message KeepWordsTokenFilter {

  optional string version = 1;

  KeepWordsTokenFilterAllOfType type = 2;

  repeated string keep_words = 3;

  optional bool keep_words_case = 4;

  optional string keep_words_path = 5;

}
enum KeepWordsTokenFilterAllOfType {

  KEEP_WORDS_TOKEN_FILTER_ALL_OF_TYPE_UNSPECIFIED = 0;
  KEEP_WORDS_TOKEN_FILTER_ALL_OF_TYPE_KEEP = 1;

}
message KeywordMarkerTokenFilter {

  optional string version = 1;

  KeywordMarkerTokenFilterAllOfType type = 2;

  optional bool ignore_case = 3;

  repeated string keywords = 4;

  optional string keywords_path = 5;

  optional string keywords_pattern = 6;

}
enum KeywordMarkerTokenFilterAllOfType {

  KEYWORD_MARKER_TOKEN_FILTER_ALL_OF_TYPE_UNSPECIFIED = 0;
  KEYWORD_MARKER_TOKEN_FILTER_ALL_OF_TYPE_KEYWORD_MARKER = 1;

}
message KeywordTokenizer {

  optional string version = 1;

  KeywordTokenizerAllOfType type = 2;

  int32 buffer_size = 3;

}
enum KeywordTokenizerAllOfType {

  KEYWORD_TOKENIZER_ALL_OF_TYPE_UNSPECIFIED = 0;
  KEYWORD_TOKENIZER_ALL_OF_TYPE_KEYWORD = 1;

}
message KuromojiIterationMarkCharFilter {

  optional string version = 1;

  KuromojiIterationMarkCharFilterAllOfType type = 2;

  bool normalize_kana = 3;

  bool normalize_kanji = 4;

}
enum KuromojiIterationMarkCharFilterAllOfType {

  KUROMOJI_ITERATION_MARK_CHAR_FILTER_ALL_OF_TYPE_UNSPECIFIED = 0;
  KUROMOJI_ITERATION_MARK_CHAR_FILTER_ALL_OF_TYPE_KUROMOJI_ITERATION_MARK = 1;

}
message KuromojiPartOfSpeechTokenFilter {

  optional string version = 1;

  KuromojiPartOfSpeechTokenFilterAllOfType type = 2;

  repeated string stoptags = 3;

}
enum KuromojiPartOfSpeechTokenFilterAllOfType {

  KUROMOJI_PART_OF_SPEECH_TOKEN_FILTER_ALL_OF_TYPE_UNSPECIFIED = 0;
  KUROMOJI_PART_OF_SPEECH_TOKEN_FILTER_ALL_OF_TYPE_KUROMOJI_PART_OF_SPEECH = 1;

}
message KuromojiReadingFormTokenFilter {

  optional string version = 1;

  KuromojiReadingFormTokenFilterAllOfType type = 2;

  bool use_romaji = 3;

}
enum KuromojiReadingFormTokenFilterAllOfType {

  KUROMOJI_READING_FORM_TOKEN_FILTER_ALL_OF_TYPE_UNSPECIFIED = 0;
  KUROMOJI_READING_FORM_TOKEN_FILTER_ALL_OF_TYPE_KUROMOJI_READINGFORM = 1;

}
message KuromojiStemmerTokenFilter {

  optional string version = 1;

  KuromojiStemmerTokenFilterAllOfType type = 2;

  int32 minimum_length = 3;

}
enum KuromojiStemmerTokenFilterAllOfType {

  KUROMOJI_STEMMER_TOKEN_FILTER_ALL_OF_TYPE_UNSPECIFIED = 0;
  KUROMOJI_STEMMER_TOKEN_FILTER_ALL_OF_TYPE_KUROMOJI_STEMMER = 1;

}
enum KuromojiTokenizationMode {

  KUROMOJI_TOKENIZATION_MODE_UNSPECIFIED = 0;
  KUROMOJI_TOKENIZATION_MODE_EXTENDED = 1;
  KUROMOJI_TOKENIZATION_MODE_NORMAL = 2;
  KUROMOJI_TOKENIZATION_MODE_SEARCH = 3;

}
message KuromojiTokenizer {

  optional string version = 1;

  KuromojiTokenizerAllOfType type = 2;

  optional bool discard_punctuation = 3;

  KuromojiTokenizationMode mode = 4;

  optional int32 nbest_cost = 5;

  optional string nbest_examples = 6;

  optional string user_dictionary = 7;

  repeated string user_dictionary_rules = 8;

  optional bool discard_compound_token = 9;

}
enum KuromojiTokenizerAllOfType {

  KUROMOJI_TOKENIZER_ALL_OF_TYPE_UNSPECIFIED = 0;
  KUROMOJI_TOKENIZER_ALL_OF_TYPE_KUROMOJI_TOKENIZER = 1;

}
message LengthTokenFilter {

  optional string version = 1;

  LengthTokenFilterAllOfType type = 2;

  optional int32 max = 3;

  optional int32 min = 4;

}
enum LengthTokenFilterAllOfType {

  LENGTH_TOKEN_FILTER_ALL_OF_TYPE_UNSPECIFIED = 0;
  LENGTH_TOKEN_FILTER_ALL_OF_TYPE_LENGTH = 1;

}
message LetterTokenizer {

  optional string version = 1;

  LetterTokenizerAllOfType type = 2;

}
enum LetterTokenizerAllOfType {

  LETTER_TOKENIZER_ALL_OF_TYPE_UNSPECIFIED = 0;
  LETTER_TOKENIZER_ALL_OF_TYPE_LETTER = 1;

}
message LimitTokenCountTokenFilter {

  optional string version = 1;

  LimitTokenCountTokenFilterAllOfType type = 2;

  optional bool consume_all_tokens = 3;

  optional StringifiedInteger max_token_count = 4;

}
enum LimitTokenCountTokenFilterAllOfType {

  LIMIT_TOKEN_COUNT_TOKEN_FILTER_ALL_OF_TYPE_UNSPECIFIED = 0;
  LIMIT_TOKEN_COUNT_TOKEN_FILTER_ALL_OF_TYPE_LIMIT = 1;

}
message LowercaseTokenFilter {

  optional string version = 1;

  LowercaseTokenFilterAllOfType type = 2;

  optional string language = 3;

}
enum LowercaseTokenFilterAllOfType {

  LOWERCASE_TOKEN_FILTER_ALL_OF_TYPE_UNSPECIFIED = 0;
  LOWERCASE_TOKEN_FILTER_ALL_OF_TYPE_LOWERCASE = 1;

}
message LowercaseTokenizer {

  optional string version = 1;

  LowercaseTokenizerAllOfType type = 2;

}
enum LowercaseTokenizerAllOfType {

  LOWERCASE_TOKENIZER_ALL_OF_TYPE_UNSPECIFIED = 0;
  LOWERCASE_TOKENIZER_ALL_OF_TYPE_LOWERCASE = 1;

}
message MappingCharFilter {

  optional string version = 1;

  MappingCharFilterAllOfType type = 2;

  repeated string mappings = 3;

  optional string mappings_path = 4;

}
enum MappingCharFilterAllOfType {

  MAPPING_CHAR_FILTER_ALL_OF_TYPE_UNSPECIFIED = 0;
  MAPPING_CHAR_FILTER_ALL_OF_TYPE_MAPPING = 1;

}
message MultiplexerTokenFilter {

  optional string version = 1;

  MultiplexerTokenFilterAllOfType type = 2;

  repeated string filters = 3;

  optional StringifiedBoolean preserve_original = 4;

}
enum MultiplexerTokenFilterAllOfType {

  MULTIPLEXER_TOKEN_FILTER_ALL_OF_TYPE_UNSPECIFIED = 0;
  MULTIPLEXER_TOKEN_FILTER_ALL_OF_TYPE_MULTIPLEXER = 1;

}
message NGramTokenFilter {

  optional string version = 1;

  NGramTokenFilterAllOfType type = 2;

  optional int32 max_gram = 3;

  optional int32 min_gram = 4;

  optional StringifiedBoolean preserve_original = 5;

}
enum NGramTokenFilterAllOfType {

  N_GRAM_TOKEN_FILTER_ALL_OF_TYPE_UNSPECIFIED = 0;
  N_GRAM_TOKEN_FILTER_ALL_OF_TYPE_NGRAM = 1;

}
message NGramTokenizer {

  optional string version = 1;

  NGramTokenizerAllOfType type = 2;

  optional string custom_token_chars = 3;

  int32 max_gram = 4;

  int32 min_gram = 5;

  repeated TokenChar token_chars = 6;

}
enum NGramTokenizerAllOfType {

  N_GRAM_TOKENIZER_ALL_OF_TYPE_UNSPECIFIED = 0;
  N_GRAM_TOKENIZER_ALL_OF_TYPE_NGRAM = 1;

}
enum NoriDecompoundMode {

  NORI_DECOMPOUND_MODE_UNSPECIFIED = 0;
  NORI_DECOMPOUND_MODE_DISCARD = 1;
  NORI_DECOMPOUND_MODE_MIXED = 2;
  NORI_DECOMPOUND_MODE_NONE = 3;

}
message NoriPartOfSpeechTokenFilter {

  optional string version = 1;

  NoriPartOfSpeechTokenFilterAllOfType type = 2;

  repeated string stoptags = 3;

}
enum NoriPartOfSpeechTokenFilterAllOfType {

  NORI_PART_OF_SPEECH_TOKEN_FILTER_ALL_OF_TYPE_UNSPECIFIED = 0;
  NORI_PART_OF_SPEECH_TOKEN_FILTER_ALL_OF_TYPE_NORI_PART_OF_SPEECH = 1;

}
message NoriTokenizer {

  optional string version = 1;

  NoriTokenizerAllOfType type = 2;

  optional NoriDecompoundMode decompound_mode = 3;

  optional bool discard_punctuation = 4;

  optional string user_dictionary = 5;

  repeated string user_dictionary_rules = 6;

}
enum NoriTokenizerAllOfType {

  NORI_TOKENIZER_ALL_OF_TYPE_UNSPECIFIED = 0;
  NORI_TOKENIZER_ALL_OF_TYPE_NORI_TOKENIZER = 1;

}
message PathHierarchyTokenizer {

  optional string version = 1;

  PathHierarchyTokenizerAllOfType type = 2;

  StringifiedInteger buffer_size = 3;

  string delimiter = 4;

  optional string replacement = 5;

  StringifiedBoolean reverse = 6;

  StringifiedInteger skip = 7;

}
enum PathHierarchyTokenizerAllOfType {

  PATH_HIERARCHY_TOKENIZER_ALL_OF_TYPE_UNSPECIFIED = 0;
  PATH_HIERARCHY_TOKENIZER_ALL_OF_TYPE_PATH_HIERARCHY = 1;

}
message PatternCaptureTokenFilter {

  optional string version = 1;

  PatternCaptureTokenFilterAllOfType type = 2;

  repeated string patterns = 3;

  optional StringifiedBoolean preserve_original = 4;

}
enum PatternCaptureTokenFilterAllOfType {

  PATTERN_CAPTURE_TOKEN_FILTER_ALL_OF_TYPE_UNSPECIFIED = 0;
  PATTERN_CAPTURE_TOKEN_FILTER_ALL_OF_TYPE_PATTERN_CAPTURE = 1;

}
message PatternReplaceCharFilter {

  optional string version = 1;

  PatternReplaceCharFilterAllOfType type = 2;

  optional string flags = 3;

  string pattern = 4;

  optional string replacement = 5;

}
enum PatternReplaceCharFilterAllOfType {

  PATTERN_REPLACE_CHAR_FILTER_ALL_OF_TYPE_UNSPECIFIED = 0;
  PATTERN_REPLACE_CHAR_FILTER_ALL_OF_TYPE_PATTERN_REPLACE = 1;

}
message PatternReplaceTokenFilter {

  optional string version = 1;

  PatternReplaceTokenFilterAllOfType type = 2;

  optional bool all = 3;

  optional string flags = 4;

  string pattern = 5;

  optional string replacement = 6;

}
enum PatternReplaceTokenFilterAllOfType {

  PATTERN_REPLACE_TOKEN_FILTER_ALL_OF_TYPE_UNSPECIFIED = 0;
  PATTERN_REPLACE_TOKEN_FILTER_ALL_OF_TYPE_PATTERN_REPLACE = 1;

}
message PatternTokenizer {

  optional string version = 1;

  PatternTokenizerAllOfType type = 2;

  optional string flags = 3;

  optional int32 group = 4;

  optional string pattern = 5;

}
enum PatternTokenizerAllOfType {

  PATTERN_TOKENIZER_ALL_OF_TYPE_UNSPECIFIED = 0;
  PATTERN_TOKENIZER_ALL_OF_TYPE_PATTERN = 1;

}
message PersianStemTokenFilter {

  optional string version = 1;

  PersianStemTokenFilterAllOfType type = 2;

}
enum PersianStemTokenFilterAllOfType {

  PERSIAN_STEM_TOKEN_FILTER_ALL_OF_TYPE_UNSPECIFIED = 0;
  PERSIAN_STEM_TOKEN_FILTER_ALL_OF_TYPE_PERSIAN_STEM = 1;

}
enum PhoneticEncoder {

  PHONETIC_ENCODER_UNSPECIFIED = 0;
  PHONETIC_ENCODER_BEIDER_MORSE = 1;
  PHONETIC_ENCODER_CAVERPHONE1 = 2;
  PHONETIC_ENCODER_CAVERPHONE2 = 3;
  PHONETIC_ENCODER_COLOGNE = 4;
  PHONETIC_ENCODER_DAITCH_MOKOTOFF = 5;
  PHONETIC_ENCODER_DOUBLE_METAPHONE = 6;
  PHONETIC_ENCODER_HAASEPHONETIK = 7;
  PHONETIC_ENCODER_KOELNERPHONETIK = 8;
  PHONETIC_ENCODER_METAPHONE = 9;
  PHONETIC_ENCODER_NYSIIS = 10;
  PHONETIC_ENCODER_REFINED_SOUNDEX = 11;
  PHONETIC_ENCODER_SOUNDEX = 12;

}
enum PhoneticLanguage {

  PHONETIC_LANGUAGE_UNSPECIFIED = 0;
  PHONETIC_LANGUAGE_ANY = 1;
  PHONETIC_LANGUAGE_COMMON = 2;
  PHONETIC_LANGUAGE_CYRILLIC = 3;
  PHONETIC_LANGUAGE_ENGLISH = 4;
  PHONETIC_LANGUAGE_FRENCH = 5;
  PHONETIC_LANGUAGE_GERMAN = 6;
  PHONETIC_LANGUAGE_HEBREW = 7;
  PHONETIC_LANGUAGE_HUNGARIAN = 8;
  PHONETIC_LANGUAGE_POLISH = 9;
  PHONETIC_LANGUAGE_ROMANIAN = 10;
  PHONETIC_LANGUAGE_RUSSIAN = 11;
  PHONETIC_LANGUAGE_SPANISH = 12;

}
enum PhoneticNameType {

  PHONETIC_NAME_TYPE_UNSPECIFIED = 0;
  PHONETIC_NAME_TYPE_ASHKENAZI = 1;
  PHONETIC_NAME_TYPE_GENERIC = 2;
  PHONETIC_NAME_TYPE_SEPHARDIC = 3;

}
enum PhoneticRuleType {

  PHONETIC_RULE_TYPE_UNSPECIFIED = 0;
  PHONETIC_RULE_TYPE_APPROX = 1;
  PHONETIC_RULE_TYPE_EXACT = 2;

}
message PhoneticTokenFilter {

  optional string version = 1;

  PhoneticTokenFilterAllOfType type = 2;

  PhoneticEncoder encoder = 3;

  repeated PhoneticLanguage languageset = 4;

  optional int32 max_code_len = 5;

  PhoneticNameType name_type = 6;

  optional bool replace = 7;

  PhoneticRuleType rule_type = 8;

}
enum PhoneticTokenFilterAllOfType {

  PHONETIC_TOKEN_FILTER_ALL_OF_TYPE_UNSPECIFIED = 0;
  PHONETIC_TOKEN_FILTER_ALL_OF_TYPE_PHONETIC = 1;

}
message PorterStemTokenFilter {

  optional string version = 1;

  PorterStemTokenFilterAllOfType type = 2;

}
enum PorterStemTokenFilterAllOfType {

  PORTER_STEM_TOKEN_FILTER_ALL_OF_TYPE_UNSPECIFIED = 0;
  PORTER_STEM_TOKEN_FILTER_ALL_OF_TYPE_PORTER_STEM = 1;

}
message PredicateTokenFilter {

  optional string version = 1;

  PredicateTokenFilterAllOfType type = 2;

  Script script = 3;

}
enum PredicateTokenFilterAllOfType {

  PREDICATE_TOKEN_FILTER_ALL_OF_TYPE_UNSPECIFIED = 0;
  PREDICATE_TOKEN_FILTER_ALL_OF_TYPE_PREDICATE_TOKEN_FILTER = 1;

}
message RemoveDuplicatesTokenFilter {

  optional string version = 1;

  RemoveDuplicatesTokenFilterAllOfType type = 2;

}
enum RemoveDuplicatesTokenFilterAllOfType {

  REMOVE_DUPLICATES_TOKEN_FILTER_ALL_OF_TYPE_UNSPECIFIED = 0;
  REMOVE_DUPLICATES_TOKEN_FILTER_ALL_OF_TYPE_REMOVE_DUPLICATES = 1;

}
message ReverseTokenFilter {

  optional string version = 1;

  ReverseTokenFilterAllOfType type = 2;

}
enum ReverseTokenFilterAllOfType {

  REVERSE_TOKEN_FILTER_ALL_OF_TYPE_UNSPECIFIED = 0;
  REVERSE_TOKEN_FILTER_ALL_OF_TYPE_REVERSE = 1;

}
message Script {

  oneof script {

    InlineScript inline = 1;

    StoredScriptId stored = 2;

  }
}
message ScriptBase {

  // Specifies any named parameters that are passed into the script as variables.  Use parameters instead of hard-coded values to decrease compilation time. 
  optional ObjectMap params = 1;

}
message ScriptLanguage {

  oneof script_language {

    BuiltinScriptLanguage builtin = 1;

    string custom = 2;

  }
}
message ShingleTokenFilter {

  optional string version = 1;

  ShingleTokenFilterAllOfType type = 2;

  optional string filler_token = 3;

  optional StringifiedInteger max_shingle_size = 4;

  optional StringifiedInteger min_shingle_size = 5;

  optional bool output_unigrams = 6;

  optional bool output_unigrams_if_no_shingles = 7;

  optional string token_separator = 8;

}
enum ShingleTokenFilterAllOfType {

  SHINGLE_TOKEN_FILTER_ALL_OF_TYPE_UNSPECIFIED = 0;
  SHINGLE_TOKEN_FILTER_ALL_OF_TYPE_SHINGLE = 1;

}
message SimplePatternSplitTokenizer {

  optional string version = 1;

  SimplePatternSplitTokenizerAllOfType type = 2;

  optional string pattern = 3;

}
enum SimplePatternSplitTokenizerAllOfType {

  SIMPLE_PATTERN_SPLIT_TOKENIZER_ALL_OF_TYPE_UNSPECIFIED = 0;
  SIMPLE_PATTERN_SPLIT_TOKENIZER_ALL_OF_TYPE_SIMPLE_PATTERN_SPLIT = 1;

}
message SimplePatternTokenizer {

  optional string version = 1;

  SimplePatternTokenizerAllOfType type = 2;

  optional string pattern = 3;

}
enum SimplePatternTokenizerAllOfType {

  SIMPLE_PATTERN_TOKENIZER_ALL_OF_TYPE_UNSPECIFIED = 0;
  SIMPLE_PATTERN_TOKENIZER_ALL_OF_TYPE_SIMPLE_PATTERN = 1;

}
message SmartcnStopTokenFilter {

  optional string version = 1;

  SmartcnStopTokenFilterAllOfType type = 2;

}
enum SmartcnStopTokenFilterAllOfType {

  SMARTCN_STOP_TOKEN_FILTER_ALL_OF_TYPE_UNSPECIFIED = 0;
  SMARTCN_STOP_TOKEN_FILTER_ALL_OF_TYPE_SMARTCN_STOP = 1;

}
message SmartcnTokenizer {

  optional string version = 1;

  SmartcnTokenizerAllOfType type = 2;

}
enum SmartcnTokenizerAllOfType {

  SMARTCN_TOKENIZER_ALL_OF_TYPE_UNSPECIFIED = 0;
  SMARTCN_TOKENIZER_ALL_OF_TYPE_SMARTCN_TOKENIZER = 1;

}
enum SnowballLanguage {

  SNOWBALL_LANGUAGE_UNSPECIFIED = 0;
  SNOWBALL_LANGUAGE_ARMENIAN = 1;
  SNOWBALL_LANGUAGE_BASQUE = 2;
  SNOWBALL_LANGUAGE_CATALAN = 3;
  SNOWBALL_LANGUAGE_DANISH = 4;
  SNOWBALL_LANGUAGE_DUTCH = 5;
  SNOWBALL_LANGUAGE_ENGLISH = 6;
  SNOWBALL_LANGUAGE_FINNISH = 7;
  SNOWBALL_LANGUAGE_FRENCH = 8;
  SNOWBALL_LANGUAGE_GERMAN = 9;
  SNOWBALL_LANGUAGE_GERMAN2 = 10;
  SNOWBALL_LANGUAGE_HUNGARIAN = 11;
  SNOWBALL_LANGUAGE_ITALIAN = 12;
  SNOWBALL_LANGUAGE_KP = 13;
  SNOWBALL_LANGUAGE_LOVINS = 14;
  SNOWBALL_LANGUAGE_NORWEGIAN = 15;
  SNOWBALL_LANGUAGE_PORTER = 16;
  SNOWBALL_LANGUAGE_PORTUGUESE = 17;
  SNOWBALL_LANGUAGE_ROMANIAN = 18;
  SNOWBALL_LANGUAGE_RUSSIAN = 19;
  SNOWBALL_LANGUAGE_SPANISH = 20;
  SNOWBALL_LANGUAGE_SWEDISH = 21;
  SNOWBALL_LANGUAGE_TURKISH = 22;

}
message SnowballTokenFilter {

  optional string version = 1;

  SnowballTokenFilterAllOfType type = 2;

  SnowballLanguage language = 3;

}
enum SnowballTokenFilterAllOfType {

  SNOWBALL_TOKEN_FILTER_ALL_OF_TYPE_UNSPECIFIED = 0;
  SNOWBALL_TOKEN_FILTER_ALL_OF_TYPE_SNOWBALL = 1;

}
message StandardTokenizer {

  optional string version = 1;

  StandardTokenizerAllOfType type = 2;

  optional int32 max_token_length = 3;

}
enum StandardTokenizerAllOfType {

  STANDARD_TOKENIZER_ALL_OF_TYPE_UNSPECIFIED = 0;
  STANDARD_TOKENIZER_ALL_OF_TYPE_STANDARD = 1;

}
message StemmerOverrideTokenFilter {

  optional string version = 1;

  StemmerOverrideTokenFilterAllOfType type = 2;

  repeated string rules = 3;

  optional string rules_path = 4;

}
enum StemmerOverrideTokenFilterAllOfType {

  STEMMER_OVERRIDE_TOKEN_FILTER_ALL_OF_TYPE_UNSPECIFIED = 0;
  STEMMER_OVERRIDE_TOKEN_FILTER_ALL_OF_TYPE_STEMMER_OVERRIDE = 1;

}
message StemmerTokenFilter {

  optional string version = 1;

  StemmerTokenFilterAllOfType type = 2;

  optional string language = 3;

}
enum StemmerTokenFilterAllOfType {

  STEMMER_TOKEN_FILTER_ALL_OF_TYPE_UNSPECIFIED = 0;
  STEMMER_TOKEN_FILTER_ALL_OF_TYPE_STEMMER = 1;

}
message StopTokenFilter {

  optional string version = 1;

  StopTokenFilterAllOfType type = 2;

  optional bool ignore_case = 3;

  optional bool remove_trailing = 4;

  repeated string stopwords = 5;

  optional string stopwords_path = 6;

}
enum StopTokenFilterAllOfType {

  STOP_TOKEN_FILTER_ALL_OF_TYPE_UNSPECIFIED = 0;
  STOP_TOKEN_FILTER_ALL_OF_TYPE_STOP = 1;

}
message StoredScriptId {

  // Specifies any named parameters that are passed into the script as variables.  Use parameters instead of hard-coded values to decrease compilation time. 
  optional ObjectMap params = 1;

  // The unique identifier for a resource.
  string id = 2;

}
message StringifiedBoolean {

  oneof stringified_boolean {

    bool bool = 1;

    string string = 2;

  }
}
message StringifiedInteger {

  oneof stringified_integer {

    int32 int32 = 1;

    string string = 2;

  }
}
enum SynonymFormat {

  SYNONYM_FORMAT_UNSPECIFIED = 0;
  SYNONYM_FORMAT_SOLR = 1;
  SYNONYM_FORMAT_WORDNET = 2;

}
message SynonymGraphTokenFilter {

  optional string version = 1;

  SynonymGraphTokenFilterAllOfType type = 2;

  optional bool expand = 3;

  optional SynonymFormat format = 4;

  optional bool lenient = 5;

  repeated string synonyms = 6;

  optional string synonyms_path = 7;

  optional string tokenizer = 8;

  optional bool updateable = 9;

}
enum SynonymGraphTokenFilterAllOfType {

  SYNONYM_GRAPH_TOKEN_FILTER_ALL_OF_TYPE_UNSPECIFIED = 0;
  SYNONYM_GRAPH_TOKEN_FILTER_ALL_OF_TYPE_SYNONYM_GRAPH = 1;

}
message SynonymTokenFilter {

  optional string version = 1;

  SynonymTokenFilterAllOfType type = 2;

  optional bool expand = 3;

  optional SynonymFormat format = 4;

  optional bool lenient = 5;

  repeated string synonyms = 6;

  optional string synonyms_path = 7;

  optional string tokenizer = 8;

  optional bool updateable = 9;

}
enum SynonymTokenFilterAllOfType {

  SYNONYM_TOKEN_FILTER_ALL_OF_TYPE_UNSPECIFIED = 0;
  SYNONYM_TOKEN_FILTER_ALL_OF_TYPE_SYNONYM = 1;

}
enum TokenChar {

  TOKEN_CHAR_UNSPECIFIED = 0;
  TOKEN_CHAR_CUSTOM = 1;
  TOKEN_CHAR_DIGIT = 2;
  TOKEN_CHAR_LETTER = 3;
  TOKEN_CHAR_PUNCTUATION = 4;
  TOKEN_CHAR_SYMBOL = 5;
  TOKEN_CHAR_WHITESPACE = 6;

}
message TokenDetail {

  // The name of the token filter or tokenizer.
  string name = 1;

  // The list of tokens produced.
  repeated ExplainAnalyzeToken tokens = 2;

}
message TokenFilter {

  oneof token_filter {

    string name = 1;

    TokenFilterDefinition definition = 2;

  }
}
message TokenFilterBase {

  optional string version = 1;

}
message TokenFilterDefinition {

  oneof token_filter_definition {

    AsciiFoldingTokenFilter ascii_folding_token_filter = 1;

    CommonGramsTokenFilter common_grams_token_filter = 2;

    ConditionTokenFilter condition_token_filter = 3;

    DelimitedPayloadTokenFilter delimited_payload_token_filter = 4;

    EdgeNGramTokenFilter edge_n_gram_token_filter = 5;

    ElisionTokenFilter elision_token_filter = 6;

    FingerprintTokenFilter fingerprint_token_filter = 7;

    HunspellTokenFilter hunspell_token_filter = 8;

    HyphenationDecompounderTokenFilter hyphenation_decompounder_token_filter = 9;

    KeepTypesTokenFilter keep_types_token_filter = 10;

    KeepWordsTokenFilter keep_words_token_filter = 11;

    KeywordMarkerTokenFilter keyword_marker_token_filter = 12;

    KStemTokenFilter k_stem_token_filter = 13;

    LengthTokenFilter length_token_filter = 14;

    LimitTokenCountTokenFilter limit_token_count_token_filter = 15;

    LowercaseTokenFilter lowercase_token_filter = 16;

    MultiplexerTokenFilter multiplexer_token_filter = 17;

    NGramTokenFilter n_gram_token_filter = 18;

    NoriPartOfSpeechTokenFilter nori_part_of_speech_token_filter = 19;

    PatternCaptureTokenFilter pattern_capture_token_filter = 20;

    PatternReplaceTokenFilter pattern_replace_token_filter = 21;

    PersianStemTokenFilter persian_stem_token_filter = 22;

    PorterStemTokenFilter porter_stem_token_filter = 23;

    PredicateTokenFilter predicate_token_filter = 24;

    RemoveDuplicatesTokenFilter remove_duplicates_token_filter = 25;

    ReverseTokenFilter reverse_token_filter = 26;

    ShingleTokenFilter shingle_token_filter = 27;

    SnowballTokenFilter snowball_token_filter = 28;

    StemmerOverrideTokenFilter stemmer_override_token_filter = 29;

    StemmerTokenFilter stemmer_token_filter = 30;

    StopTokenFilter stop_token_filter = 31;

    SynonymGraphTokenFilter synonym_graph_token_filter = 32;

    SynonymTokenFilter synonym_token_filter = 33;

    TrimTokenFilter trim_token_filter = 34;

    TruncateTokenFilter truncate_token_filter = 35;

    UniqueTokenFilter unique_token_filter = 36;

    UppercaseTokenFilter uppercase_token_filter = 37;

    WordDelimiterGraphTokenFilter word_delimiter_graph_token_filter = 38;

    WordDelimiterTokenFilter word_delimiter_token_filter = 39;

    KuromojiStemmerTokenFilter kuromoji_stemmer_token_filter = 40;

    KuromojiReadingFormTokenFilter kuromoji_reading_form_token_filter = 41;

    KuromojiPartOfSpeechTokenFilter kuromoji_part_of_speech_token_filter = 42;

    IcuTokenizer icu_tokenizer = 43;

    IcuCollationTokenFilter icu_collation_token_filter = 44;

    IcuFoldingTokenFilter icu_folding_token_filter = 45;

    IcuNormalizationTokenFilter icu_normalization_token_filter = 46;

    IcuTransformTokenFilter icu_transform_token_filter = 47;

    PhoneticTokenFilter phonetic_token_filter = 48;

    DictionaryDecompounderTokenFilter dictionary_decompounder_token_filter = 49;

    SmartcnStopTokenFilter smartcn_stop_token_filter = 50;

  }
}
message Tokenizer {

  oneof tokenizer {

    string name = 1;

    TokenizerDefinition definition = 2;

  }
}
message TokenizerBase {

  optional string version = 1;

}
message TokenizerDefinition {

  oneof tokenizer_definition {

    CharGroupTokenizer char_group_tokenizer = 1;

    EdgeNGramTokenizer edge_n_gram_tokenizer = 2;

    KeywordTokenizer keyword_tokenizer = 3;

    LetterTokenizer letter_tokenizer = 4;

    LowercaseTokenizer lowercase_tokenizer = 5;

    NGramTokenizer n_gram_tokenizer = 6;

    NoriTokenizer nori_tokenizer = 7;

    PathHierarchyTokenizer path_hierarchy_tokenizer = 8;

    StandardTokenizer standard_tokenizer = 9;

    UaxEmailUrlTokenizer uax_email_url_tokenizer = 10;

    WhitespaceTokenizer whitespace_tokenizer = 11;

    KuromojiTokenizer kuromoji_tokenizer = 12;

    PatternTokenizer pattern_tokenizer = 13;

    SimplePatternTokenizer simple_pattern_tokenizer = 14;

    SimplePatternSplitTokenizer simple_pattern_split_tokenizer = 15;

    IcuTokenizer icu_tokenizer = 16;

    SmartcnTokenizer smartcn_tokenizer = 17;

  }
}
message TrimTokenFilter {

  optional string version = 1;

  TrimTokenFilterAllOfType type = 2;

}
enum TrimTokenFilterAllOfType {

  TRIM_TOKEN_FILTER_ALL_OF_TYPE_UNSPECIFIED = 0;
  TRIM_TOKEN_FILTER_ALL_OF_TYPE_TRIM = 1;

}
message TruncateTokenFilter {

  optional string version = 1;

  TruncateTokenFilterAllOfType type = 2;

  optional int32 length = 3;

}
enum TruncateTokenFilterAllOfType {

  TRUNCATE_TOKEN_FILTER_ALL_OF_TYPE_UNSPECIFIED = 0;
  TRUNCATE_TOKEN_FILTER_ALL_OF_TYPE_TRUNCATE = 1;

}
message UaxEmailUrlTokenizer {

  optional string version = 1;

  UaxEmailUrlTokenizerAllOfType type = 2;

  optional int32 max_token_length = 3;

}
enum UaxEmailUrlTokenizerAllOfType {

  UAX_EMAIL_URL_TOKENIZER_ALL_OF_TYPE_UNSPECIFIED = 0;
  UAX_EMAIL_URL_TOKENIZER_ALL_OF_TYPE_UAX_URL_EMAIL = 1;

}
message UniqueTokenFilter {

  optional string version = 1;

  UniqueTokenFilterAllOfType type = 2;

  optional bool only_on_same_position = 3;

}
enum UniqueTokenFilterAllOfType {

  UNIQUE_TOKEN_FILTER_ALL_OF_TYPE_UNSPECIFIED = 0;
  UNIQUE_TOKEN_FILTER_ALL_OF_TYPE_UNIQUE = 1;

}
message UppercaseTokenFilter {

  optional string version = 1;

  UppercaseTokenFilterAllOfType type = 2;

}
enum UppercaseTokenFilterAllOfType {

  UPPERCASE_TOKEN_FILTER_ALL_OF_TYPE_UNSPECIFIED = 0;
  UPPERCASE_TOKEN_FILTER_ALL_OF_TYPE_UPPERCASE = 1;

}
message WhitespaceTokenizer {

  optional string version = 1;

  WhitespaceTokenizerAllOfType type = 2;

  optional int32 max_token_length = 3;

}
enum WhitespaceTokenizerAllOfType {

  WHITESPACE_TOKENIZER_ALL_OF_TYPE_UNSPECIFIED = 0;
  WHITESPACE_TOKENIZER_ALL_OF_TYPE_WHITESPACE = 1;

}
message WordDelimiterGraphTokenFilter {

  optional string version = 1;

  WordDelimiterGraphTokenFilterAllOfType type = 2;

  optional bool adjust_offsets = 3;

  optional bool catenate_all = 4;

  optional bool catenate_numbers = 5;

  optional bool catenate_words = 6;

  optional bool generate_number_parts = 7;

  optional bool generate_word_parts = 8;

  optional bool ignore_keywords = 9;

  optional StringifiedBoolean preserve_original = 10;

  repeated string protected_words = 11;

  optional string protected_words_path = 12;

  optional bool split_on_case_change = 13;

  optional bool split_on_numerics = 14;

  optional bool stem_english_possessive = 15;

  repeated string type_table = 16;

  optional string type_table_path = 17;

}
enum WordDelimiterGraphTokenFilterAllOfType {

  WORD_DELIMITER_GRAPH_TOKEN_FILTER_ALL_OF_TYPE_UNSPECIFIED = 0;
  WORD_DELIMITER_GRAPH_TOKEN_FILTER_ALL_OF_TYPE_WORD_DELIMITER_GRAPH = 1;

}
message WordDelimiterTokenFilter {

  optional string version = 1;

  WordDelimiterTokenFilterAllOfType type = 2;

  optional bool catenate_all = 3;

  optional bool catenate_numbers = 4;

  optional bool catenate_words = 5;

  optional bool generate_number_parts = 6;

  optional bool generate_word_parts = 7;

  optional StringifiedBoolean preserve_original = 8;

  repeated string protected_words = 9;

  optional string protected_words_path = 10;

  optional bool split_on_case_change = 11;

  optional bool split_on_numerics = 12;

  optional bool stem_english_possessive = 13;

  repeated string type_table = 14;

  optional string type_table_path = 15;

}
enum WordDelimiterTokenFilterAllOfType {

  WORD_DELIMITER_TOKEN_FILTER_ALL_OF_TYPE_UNSPECIFIED = 0;
  WORD_DELIMITER_TOKEN_FILTER_ALL_OF_TYPE_WORD_DELIMITER = 1;

}
